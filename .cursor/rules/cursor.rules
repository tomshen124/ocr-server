## Cursor AI 开发指导

### 代码生成偏好
- **语言风格**: 现代 Rust (2021 edition)，优先使用 `?` 操作符和 `Result` 类型
- **异步模式**: 所有 I/O 操作使用 `async/await`，避免阻塞调用
- **错误处理**: 统一使用 `anyhow::Result`，自定义错误类型继承 `thiserror::Error`
- **日志格式**: 使用 `tracing` 宏，结构化日志格式：`tracing::info!(field = value, "message")`

### 代码模式和最佳实践
- **状态管理**: 通过 `Arc<AppState>` 共享状态，避免全局变量
- **配置注入**: 使用依赖注入模式，配置通过构造函数传入
- **API 处理器**: 遵循 `async fn handler(State(app_state): State<Arc<AppState>>, Json(payload): Json<RequestType>) -> Result<Json<ResponseType>, AppError>` 模式
- **测试编写**: 每个公共函数都应有对应的单元测试，使用 `#[tokio::test]` 进行异步测试

## 业务领域知识

### OCR 处理流程
1. **文件接收** → 验证格式和大小 → 临时存储
2. **OCR 识别** → PaddleOCR 引擎 → 多语言文本提取
3. **规则引擎** → zen-engine 处理 → 业务规则匹配
4. **预览生成** → 主题化渲染 → PDF/HTML 输出
5. **结果返回** → 标准化响应 → 客户端展示

### 关键业务概念
- **预审**: 文档内容的自动化审查和分类
- **主题映射**: 根据文档内容自动匹配预定义主题模板
- **规则引擎**: 基于配置的业务逻辑处理引擎
- **离线部署**: 无需互联网连接的独立运行能力

## 技术决策记录

### 架构选择理由
- **Rust + Axum**: 高性能、内存安全，适合 CPU 密集型 OCR 处理
- **静态链接**: `x86_64-unknown-linux-musl` 确保部署兼容性
- **PaddleOCR**: 离线运行、多语言支持、识别准确率高
- **zen-engine**: 轻量级规则引擎，支持动态配置

### 性能考虑
- **并发模型**: 基于 tokio 的异步并发，避免线程池开销
- **内存优化**: 大文件流式处理，OCR 结果缓存策略
- **I/O 优化**: 异步文件操作，避免阻塞主线程

## Cursor 代码生成指南

### 新增 API 端点时
1. 在 `src/api/` 下创建对应模块
2. 定义请求/响应结构体，使用 `serde` 进行序列化
3. 实现处理函数，遵循错误处理模式
4. 在 `src/api/mod.rs` 中注册路由
5. 编写对应的测试用例

### 新增配置项时
1. 在 `src/util/config.rs` 中添加字段
2. 更新 `config.example.yaml` 示例
3. 在相关模块中通过 `app_state.config` 访问
4. 添加配置验证逻辑

### 错误处理模式

// 处理逻辑...

Ok(result)

undefined

## 开发调试指南

### 本地开发环境设置


### 测试数据准备
- **测试文件位置**: `tests/fixtures/`
- **OCR 测试样本**: 包含中英日韩俄文的标准测试文档
- **API 测试**: 使用 `tests/api_tests.rs` 中的集成测试

### 常用调试命令

## 生产环境维护

### 监控指标
- **关键指标**: OCR 处理时间、内存使用率、错误率、并发请求数
- **告警阈值**: 
  - OCR 处理时间 > 30s
  - 内存使用率 > 80%
  - 错误率 > 5%
  - 磁盘使用率 > 90%

### 故障处理流程
1. **服务异常**: 检查日志 → 重启服务 → 验证功能
2. **OCR 失败**: 检查模型文件 → 验证输入格式 → 重新处理
3. **内存泄漏**: 分析内存使用 → 重启服务 → 优化代码
4. **性能下降**: 检查并发数 → 分析慢查询 → 优化算法

### 版本升级检查清单
- [ ] 依赖安全性审计
- [ ] 配置文件兼容性
- [ ] API 接口向后兼容
- [ ] 数据库迁移脚本
- [ ] 性能回归测试
